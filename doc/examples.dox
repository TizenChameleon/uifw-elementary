/**
 * @page Examples Examples
 *
 * Here is a page with Elementary examples.
 *
 * @ref bg_01_example_page
 *
 * @ref bg_02_example_page
 *
 * @ref bg_03_example_page
 *
 * @ref actionslider_example_page
 *
 * @ref elm_animator_example_page_01
 *
 * @ref transit_example_01_explained
 *
 * @ref transit_example_02_explained
 *
 * @ref general_functions_example_page
 *
 * @ref calendar_example_01
 *
 * @ref calendar_example_02
 *
 * @ref calendar_example_03
 *
 * @ref calendar_example_04
 *
 * @ref calendar_example_05
 *
 * @ref calendar_example_06
 *
 * @ref clock_example

 * @ref diskselector_example_01
 *
 * @ref diskselector_example_02
 *
 * @ref flipselector_example
 *
 * @ref fileselector_example
 *
 * @ref fileselector_button_example
 *
 * @ref fileselector_entry_example
 *
 * @ref index_example_01
 *
 * @ref index_example_02
 */

/**
 * @page bg_01_example_page elm_bg - Plain color background.
 * @dontinclude bg_example_01.c
 *
 * The full code for this example can be found at @ref bg_example_01_c,
 * in the function @c test_bg_plain. It's part of the @c elementar_test
 * suite, and thus has the code for the three examples referenced by this
 * documentation.
 *
 * This first example just sets a default background with a plain color. The
 * first part consists of creating an Elementary window. It's the common
 * piece of code that you'll see everywhere in Elementary: @skip elm_main
 * @until autodel_set
 *
 * Now we really create our background object, using the window object as
 * its parent:
 *
 * @skipline bg_add
 *
 * Then we set the size hints of the background object so that it will use
 * all space available for it, and then add it as a resize object to the
 * window, making it visible in the end:
 *
 * @skip size_hint_weight_set
 * @until resize_object_add
 *
 * See @ref evas_object_size_hint_weight_set and elm_win_resize_object_add()
 * for more detailed info about these functions.
 *
 * The end of the example is quite simple, just setting the minimum and
 * maximum size of the background, so the Elementary window knows that it
 * has to have at least the minimum size. The background also won't scale to
 * a size above its maximum. Then we resize the window and show it in the
 * end:
 *
 * @skip set size hints
 * @until }
 *
 * And here we finish our very simple background object usage example.
 */

/**
 * @page bg_02_example_page elm_bg - Image background.
 * @dontinclude bg_example_02.c
 *
 * The full code for this example can be found at @ref bg_example_02_c,
 * in the function @c test_bg_image. It's part of the @c elementar_test
 * suite, and thus has the code for the three examples referenced by this
 * documentation.
 *
 * This is the second example, and shows how to use the Elementary
 * background object to set an image as background of your application.
 *
 * We start this example exactly in the same way as the previous one, even
 * when creating the background object:
 *
 * @skip elm_main
 * @until bg_add
 *
 * Now it's the different part.
 *
 * Our background will have an image, that will be displayed over the
 * background color. Before loading the image, we set the load size of the
 * image. The load size is a hint about the size that we want the image
 * displayed in the screen. It's not the exact size that the image will have,
 * but usually a bit bigger. The background object can still be scaled to a
 * size bigger than the one set here. Setting the image load size to
 * something smaller than its real size will reduce the memory used to keep
 * the pixmap representation of the image, and the time to load it. Here we
 * set the load size to 20x20 pixels, but the image is loaded with a size
 * bigger than that (since it's just a hint):
 *
 * @skipline load_size_set
 *
 * And set our background image to be centered, instead of stretched or
 * scaled, so the effect of the elm_bg_load_size_set() can be easily
 * understood:
 *
 * @skipline option_set
 *
 * We need a filename to set, so we get one from the previous installed
 * images in the @c PACKAGE_DATA_DIR, and write its full path to a buffer.
 * Then we use this buffer to set the filename in the background object:
 *
 * @skip snprintf
 * @until bg_file_set
 *
 * Notice that the third argument of the elm_bg_file_set() function is @c
 * NULL, since we are setting an image to this background. This function
 * also supports setting an edje group as background, in which case the @c
 * group parameter wouldn't be @c NULL, but be the name of the group
 * instead.
 *
 * Finally, we can set the size hints, add the background as a resize
 * object, and resize the window, exactly the same thing we do in the @ref
 * bg_01_example_page example:
 *
 * @skip size_hint
 * @until }
 *
 * And this is the end of this example.
 *
 * This example will look like this:
 *
 * @image html screenshots/bg_01.png
 * @image latex screenshots/bg_01.eps width=\textwidth
 */

/**
 * @page bg_03_example_page elm_bg - Background properties.
 * @dontinclude bg_example_03.c
 *
 * The full code for this example can be found at @ref bg_example_03_c, in the
 * function @c test_bg_options, with the callbacks @c _cb_overlay_changed, @c
 * _cb_color_changed and @c _cb_radio_changed defined in the beginning of the
 * file. It's part of the @c elementar_test suite, and thus has the code for
 * the three examples referenced by this documentation.
 *
 * This example will show the properties available for the background object,
 * and will use of some more widgets to set them.
 *
 * In order to do this, we will set some callbacks for these widgets. The
 * first is for the radio buttons that will be used to choose the option
 * passed as argument to elm_bg_option_set():
 *
 * @skip _cb_radio_changed
 * @until }
 *
 * The next callback will be used when setting the overlay (using
 * elm_bg_overlay_set()):
 *
 * @skip _cb_overlay_changed
 * @until }
 * @until }
 *
 * And the last one, used to set the color (with elm_bg_color_set()):
 *
 * @skip _cb_color_changed
 * @until }
 *
 * We will get back to what these functions do soon. If you want to know more
 * about how to set these callbacks and what these widgets are, look for:
 * @li elm_radio_add()
 * @li elm_check_add()
 * @li elm_spinner_add()
 *
 * Now going to the main function, @c test_bg_options, we have the common
 * code with the other examples:
 *
 * @skip bg-options
 * @until autodel_set
 *
 * We add a plain background to this window, so it will have the default
 * background color behind everything:
 *
 * @skip bg = elm_bg_add
 * @until evas_object_show(bg)
 *
 * Then we add a vertical box (elm_box_add()) that will hold the background
 * object that we are going to play with, as well as a horizontal box that
 * will hold widgets:
 *
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Now we add the background object that is going to be of use for our
 * example. It is an image background, as used in @ref bg_02_example_page ,
 * so the code should be familiar:
 *
 * @skip elm_bg_add
 * @until evas_object_show
 *
 * Notice the call to elm_box_pack_end(): it will pack the background object
 * in the end of the Elementary box declared above. Just refer to that
 * documentation for more info.
 *
 * Since this Elementary background is already an image background, we are
 * going to play with its other properties. We will change its option
 * (CENTER, SCALE, STRETCH, TILE), its color (RGB), and add an overlay to it.
 * For all of these properties, we are going to add widgets that will
 * configure them.
 *
 * First, lets add the horizontal box that will hold these widgets:
 * @skip hbox
 * @until align_set
 *
 * For now, just consider this @c hbox as a rectangle that will contain the
 * widgets, and will distribute them horizontally inside its content. Then we
 * add radio buttons that will allow us to choose the property to use with
 * this background:
 *
 * @skip radio_add
 * @until evas_object_show
 *
 * Again, I won't give details about the use of these widgets, just look for
 * their documentation if necessary. It's enough to know for now that we are
 * packing them in the @c hbox, setting a label for them, and the most
 * important parts: setting its value to @c ELM_BG_OPTION_CENTER and its
 * callback to @c _cb_radio_changed (the function defined in the beginning of
 * this example). We do this for the next 3 radio buttons added after this
 * one, each of them with a different value.
 *
 * Now taking a look at the code of the callback @c _cb_radio_changed again,
 * it will call elm_bg_option_set() with the value set from the checked radio
 * button, thus setting the option for this background. The background is
 * passed as argument to the @p data parameter of this callback, and is
 * referenced here as @c o_bg.
 *
 * Later we set the default value for this radio button:
 *
 * @skipline elm_radio_value_set
 *
 * Then we add a checkbox for the elm_bg_overlay_set() function:
 *
 * @skip check_add
 * @until evas_object_show
 *
 * Now look at the code of the @c _cb_overlay_changed again. If the checkbox
 * state is checked, an overlay will be added to the background. It's done by
 * creating an Edje object, and setting it with elm_bg_overlay_set() to the
 * background object. For information about what are and how to set Edje
 * object, look at the Edje documentation.
 *
 * Finally we add a spinner object (elm_spinner_add()) to be used to select
 * the color of our background. In its callback it's possible to see the call
 * to elm_bg_color_set(), which will change the color of this background.
 * This color is used by the background to fill areas where the image doesn't
 * cover (in this case, where we have an image background). The spinner is
 * also packed into the @c hbox :
 *
 * @skip elm_spinner_add
 * @until evas_object_show
 *
 * Then we just have to pack the @c hbox inside the @c box, set some size
 * hints, and show our window:
 *
 * @skip pack_end
 * @until }
 *
 * Now to see this code in action, open elementary_test, and go to the "Bg
 * Options" test. It should demonstrate what was implemented here.
 */

/**
 * @page actionslider_example_page Actionslider usage
 * @dontinclude actionslider_example_01.c
 *
 * For this example we are going to assume knowledge of evas smart callbacks
 * and some basic evas object functions. Elementary is not meant to be used
 * without evas, if you're not yet familiar with evas it probably is worth
 * checking that out.
 *
 * And now to the example, when using Elementary we start by including
 * Elementary.h:
 * @skipline #include
 *
 * Next we define some callbacks, they all share the same signature because
 * they are all to be used with evas_object_smart_callback_add().
 * The first one just prints the selected label(in two different ways):
 * @until }
 *
 * This next callback is a little more interesting, it makes the selected
 * label magnetic(except if it's the center label):
 * @until }
 *
 * This callback enables or disables the magnetic propertty of the center
 * label:
 * @until }
 *
 * And finally a callback to stop the main loop when the window is closed:
 * @until }
 *
 * To be able to create our actionsliders we need to do some setup, but this
 * isn't really relevant here, so if you want to know about that go @ref
 * Win "here".
 *
 * With all that boring stuff out of the way we can proceed to creating some
 * actionsliders.@n
 * All actionsliders are created the same way:
 * @skipline actionslider_add
 * Next we must choose where the indicator starts, and for this one we choose
 * the right, and set the right as magnetic:
 * @skipline indicator_pos_set
 * @until magnet_pos_set
 *
 * We then set the labels for the left and right, passing NULL as an argument
 * to any of the labels makes that position have no label.
 * @until Stop
 *
 * Furthermore we mark both left and right as enabled positions, if we didn't
 * do this all three positions would be enabled:
 * @until RIGHT
 *
 * Having the the enabled positions we now add a smart callback to change
 * which position is magnetic, so that only the last selected position is
 * magnetic:
 * @until NULL
 *
 * And finally we set our printing callback and show the actionslider:
 * @until object_show
 * @skip pack_end
 *
 * For our next actionslider we are going to do much as we did for the
 * previous except we are going to have the center as the magnet(and not
 * change it):
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * And another actionslider, in this one the indicator starts on the left.
 * It has labels only in the center and right, and both bositions are
 * magnetic. Because the left doesn't have a label and is not magnetic once
 * the indicator leaves it can't return:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 * @note The greyed out area is a @ref Styles "style".
 *
 * And now an actionslider with a label in the indicator, and whose magnet
 * properties change based on what was last selected:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 * @note The greyed out area is a @ref Styles "style".
 *
 * We are almost done, this next one is just an actionslider with all
 * positions magnetized and having every possible label:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * And for our last actionslider we have one that turns the magnetic property
 * on and off:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * The example will look like this:
 *
 * @image html screenshots/actionslider_01.png
 * @image latex screenshots/actionslider_01.eps width=\textwidth
 *
 * See the full source code @ref actionslider_example_01 "here"
 */

/**
 * @page elm_animator_example_page_01 Animator usage
 * @dontinclude animator_example_01.c
 *
 * For this example we will be using a bit of evas, you could animate a
 * elementary widget in much the same way, but to keep things simple we use
 * an evas_object_rectangle.
 *
 * As every other example we start with our include and a simple callback to
 * exit the app when the window is closed:
 * @skipline #include
 * @until }
 *
 * This next callback is the one that actually creates our animation, it
 * changes the size, position and color of a rectangle given to it in @a
 * data:
 * @until }
 *
 * Next we have a callback that prints a string, nothing special:
 * @until }
 *
 * This next callback is a little more interesting, it has a state variable
 * to know if the animation is currently paused or running, and it toogles
 * the state of the animation accordingly:
 * @until }
 * @until }
 * @until }
 *
 * Finally we have a callback to stop the animation:
 * @until }
 *
 * As with every example we need to do a bit of setup before we can actually
 * use an animation, but for the purposes of this example that's not relevant
 * so let's just skip to the good stuff, creating an animator:
 * @skipline animator_add
 * @note Since elm_animator is not a widget we can give it a NULL parent.
 *
 * Now that we have an elm_animator we set it's duration to 1 second:
 * @line duration_set
 *
 * We would also like our animation to be reversible, so:
 * @line reverse_set
 *
 * We also set our animation to repeat as many times as possible, which will
 * mean that _end_cb will only be called after UINT_MAX * 2 seconds(UINT_MAX
 * for the animation running forward and UNIT_MAX for the animation running
 * backwards):
 * @line repeat_set
 *
 * To add some fun to our animation we will use the IN_OUT curve style:
 * @line curve_style
 *
 * To actually animate anything we need an operation callback:
 * @line operation_callback
 *
 * Even though we set our animation to repeat for a very long time we are
 * going to set a end callback to it:
 * @line completion_callback
 * @note Notice that stoping the animation with the stop button will not make
 * _end_cb be called.
 *
 * Now that we have fully set up our animator we can tell it to start
 * animating:
 * @line animate
 *
 * There's a bit more of code that doesn't really matter to use so we skip
 * right down to our last interesting point:
 * @skipline animator_del
 * @note Because we created our animator with no parent we need to delete it
 * ourselves.
 *
 * The example should look like this:
 *
 * @image html screenshots/animator_example_01.png
 * @image latex screenshots/animator_example_01.eps width=\textwidth
 * @n
 * @image html screenshots/animator_example_02.png
 * @image latex screenshots/animator_example_02.eps width=\textwidth
 * @n
 * @image html screenshots/animator_example_03.png
 * @image latex screenshots/animator_example_03.eps width=\textwidth
 *
 * The full source code for this example can be found @ref
 * animator_example_01_c "here"
 */

/**
 * @page transit_example_03_c elm_transit - Combined effects and options.
 *
 * This example shows how to apply the following transition effects:
 * @li translation
 * @li color
 * @li rotation
 * @li wipe
 * @li zoom
 * @li resizing
 *
 * It allows you to apply more than one effect at once, and also allows to
 * set properties like event_enabled, auto_reverse, repeat_times and
 * tween_mode.
 *
 * @include transit_example_03.c
 */

/**
 * @page transit_example_04_c elm_transit - Combined effects over two objects.
 *
 * This example shows how to apply the transition effects:
 * @li flip
 * @li resizable_flip
 * @li fade
 * @li blend
 * over two objects. This kind of transition effect is used to make one
 * object disappear and another one appear on its place.
 *
 * You can mix more than one effect of this type on the same objects, and the
 * transition will apply both.
 *
 * @include transit_example_04.c
 */

/**
 * @page transit_example_01_explained elm_transit - Basic transit usage.
 * @dontinclude transit_example_01.c
 *
 * The full code for this example can be found at @ref transit_example_01_c.
 *
 * This example shows the simplest way of creating a transition and applying
 * it to an object. Similarly to every other elementary example, we create a
 * window, set its title, size, autodel property, and setup a callback to
 * exit the program when finished:
 *
 * @skip on_done
 * @until evas_object_resize
 *
 * We also add a resizeable white background to use behind our animation:
 *
 * @skip bg_add
 * @until evas_object_show
 *
 * And then we add a button that we will use to demonstrate the effects of
 * our animation:
 *
 * @skip button_add
 * @until evas_object_show(win)
 *
 * Notice that we are not adding the button with elm_win_resize_object_add()
 * because we don't want the window to control the size of the button. We
 * will use the transition to change the button size, so it could conflict
 * with something else trying to control that size.
 *
 * Now, the simplest code possible to create the resize animation:
 *
 * @skip transit_add
 * @until transit_go
 *
 * As you can see, this code is very easy to understand. First, we create the
 * transition itself with elm_transit_add(). Then we add the button to this
 * transition with elm_transit_object_add(), which means that the transition
 * will operate over this button. The effect that we want now is changing the
 * object size from 100x50 to 300x150, and can be achieved by adding the
 * resize effect with elm_transit_effect_resizing_add().
 *
 * Finally, we set the transition time to 5 seconds and start the transition
 * with elm_transit_go(). If we wanted more effects applied to this
 * button, we could add them to the same transition. See the
 * @ref transit_example_03_c to watch many transitions being applied to an
 * object.
 */

/**
 * @page transit_example_02_explained elm_transit - Chained transitions.
 * @dontinclude transit_example_02.c
 *
 * The full code for this example can be found at @ref transit_example_02_c.
 *
 * This example shows how to implement a chain of transitions. This chain is
 * used to start a transition just after another transition ended. Similarly
 * to every other elementary example, we create a window, set its title,
 * size, autodel property, and setup a callback to exit the program when
 * finished:
 *
 * @skip on_done
 * @until evas_object_resize
 *
 * We also add a resizeable white background to use behind our animation:
 *
 * @skip bg_add
 * @until evas_object_show
 *
 * This example will have a chain of 4 transitions, each of them applied to
 * one button. Thus we create 4 different buttons:
 *
 * @skip button_add
 * @until evas_object_show(bt4)
 *
 * Now we create a simple translation transition that will be started as soon
 * as the program loads. It will be our first transition, and the other
 * transitions will be started just after this transition ends:
 *
 * @skip transit_add
 * @until transit_go
 *
 * The code displayed until now has nothing different from what you have
 * already seen in @ref transit_example_01_explained, but now comes the new
 * part: instead of creating a second transition that will start later using
 * a timer, we create the it normally, and use
 * elm_transit_chain_transit_add() instead of elm_transit_go. Since we are
 * adding it in a chain after the first transition, it will start as soon as
 * the first transition ends:
 *
 * @skip transit_add
 * @until transit_chain_transit_add
 *
 * Finally we add the 2 other transitions to the chain, and run our program.
 * It will make one transition start after the other finish, and there is the
 * transition chain.
 */

/**
 * @page general_functions_example_page General (top-level) functions example
 * @dontinclude general_funcs_example.c
 *
 * As told in their documentation blocks, the
 * elm_app_compile_*_dir_set() family of functions have to be called
 * before elm_app_info_set():
 * @skip tell elm about
 * @until elm_app_info_set
 *
 * We are here setting the fallback paths to the compiling time target
 * paths, naturally. If you're building the example out of the
 * project's build system, we're assuming they are the canonical ones.
 *
 * After the program starts, elm_app_info_set() will actually run and
 * then you'll see an intrincasy: Elementary does the prefix lookup @b
 * twice. This is so because of the quicklaunch infrastructure in
 * Elementary (@ref Start), which will register a predefined prefix
 * for possible users of the launch schema. We're not hooking into a
 * quick launch, so this first call can't be avoided.
 *
 * If you ran this example from your "bindir" installation
 * directiory, no output will emerge from these both attempts -- it
 * will find the "magic" file there registered and set the prefixes
 * silently. Otherwise, you could get something like:
 @verbatim
 WARNING: Could not determine its installed prefix for 'ELM'
       so am falling back on the compiled in default:
         usr
       implied by the following:
         bindir    = usr/lib
         libdir    = usr/lib
         datadir   = usr/share/elementary
         localedir = usr/share/locale
       Try setting the following environment variables:
         ELM_PREFIX     - points to the base prefix of install
       or the next 4 variables
         ELM_BIN_DIR    - provide a specific binary directory
         ELM_LIB_DIR    - provide a specific library directory
         ELM_DATA_DIR   - provide a specific data directory
         ELM_LOCALE_DIR - provide a specific locale directory
 @endverbatim
 * if you also didn't change those environment variables (remember
 * they are also a valid way of communicating your prefix to the
 * binary) - this is the scenario where it fallbacks to the paths set
 * for compile time.
 *
 * Then, you can check the prefixes set on the standard output:
 * @skip prefix was set to
 * @until locale directory is
 *
 * In the fragment
 * @skip by using this policy
 * @until elm_win_autodel_set
 * we demonstrate the use of Elementary policies. The policy defining
 * under which circunstances our application should quit automatically
 * is set to when its last window is closed (this one has just one
 * window, though). This will save us from having to set a callback
 * ourselves on the window, like done in @ref bg_example_01_c "this"
 * example. Note that we need to tell the window to delete itself's
 * object on a request to destroy the canvas coming, with
 * elm_win_autodel_set().
 *
 * What follows is some boilerplate code, creating a frame with a @b
 * button, our object of interest, and, below, widgets to change the
 * button's behavior and exemplify the group of functions in question.
 *
 * @dontinclude general_funcs_example.c
 * We enabled the focus highlight object for this window, so that you
 * can keep track of the current focused object better:
 * @skip elm_win_focus_highlight_enabled_set
 * @until evas_object_show
 * Use the tab key to navigate through the focus chain.
 *
 * @dontinclude general_funcs_example.c
 * While creating the button, we exemplify how to use Elementary's
 * finger size information to scale our UI:
 * @skip fprintf(stdout, "Elementary
 * @until evas_object_show
 *
 * @dontinclude general_funcs_example.c
 * The first checkbox's callback is:
 * @skip static void
 * @until }
 * When unsetting the checkbox, we disable the button, which will get a new
 * decoration (greyed out) and stop receiving events. The focus chain
 * will also ignore it.
 *
 * Following, there are 2 more buttons whose actions are focus/unfocus
 * the top button, respectively:
 * @skip focus callback
 * @until }
 * and
 * @skip unfocus callback
 * @until }
 * Note the situations in which they won't take effect:
 * - the button is not allowed to get focus or
 * - the button is disabled
 *
 * The first restriction above you'll get by a second checkbox, whose
 * callback is:
 * @skip focus allow callback
 * @until }
 * Note that the button will still get mouse events, though.
 *
 * Next, there's a slider controlling the button's scale:
 * @skip scaling callback
 * @until }
 *
 * Experiment with it, so you understand the effect better. If you
 * change its value, it will mess with the button's original size,
 * naturally.
 *
 * The full code for this example can be found
 * @ref general_functions_example_c "here".
 */

/**
 * @page theme_example_01 Theme - Using extensions
 *
 * @dontinclude theme_example_01.c
 *
 * Using extensions is extremely easy, discarding the part where you have to
 * write the theme for them.
 *
 * In the following example we'll be creating two buttons, one to load or
 * unload our extension theme and one to cycle around three possible styles,
 * one of which we created.
 *
 * After including our one and only header we'll jump to the callback for
 * the buttons. First one takes care of loading or unloading our extension
 * file, relative to the default theme set (thus the @c NULL in the
 * functions first parameter).
 * @skipline Elementary.h
 * @skip static void
 * @until }
 * @until }
 * @until }
 *
 * The second button, as we said before, will just switch around different
 * styles. In this case we have three of them. The first one is our custom
 * style, named after something very unlikely to find in the default theme.
 * The other two styles are the standard and one more, anchor, which exists
 * in the default and is similar to the default, except the button vanishes
 * when the mouse is not over it.
 * @skip static void
 * @until }
 * @until }
 *
 * So what happens if the style switches to our custom one when the
 * extension is loaded? Elementary falls back to the default for the
 * widget.
 *
 * And the main function, simply enough, will create the window, set the
 * buttons and their callbacks, and just to begin with our button styled
 * we're also loading our extension at the beginning.
 * @skip int
 * @until ELM_MAIN
 *
 * In this case we wanted to easily remove extensions, but all adding an
 * extension does is tell Elementary where else it should look for themes
 * when it can't find them in the default theme. Another way to do this
 * is to set the theme search order using elm_theme_set(), but this requires
 * that the developer is careful not to override any user configuration.
 * That can be helped by adding our theme to the end of whatver is already
 * set, like in the following snippet.
 * @code
 * char buf[4096];
 * snprintf(buf, sizeof(buf), "%s:./theme_example.edj", elme_theme_get(NULL);
 * elm_theme_set(NULL, buf);
 * @endcode
 *
 * If we were using overlays instead of extensions, the same thing applies,
 * but the custom theme must be added to the front of the search path.
 *
 * In the end, we should be looking at something like this:
 *
 * @image html screenshots/theme_example_01.png
 * @image latex screenshots/theme_example_01.eps width=\textwidth
 *
 * That's all. Boringly simple, and the full code in one piece can be found
 * @ref theme_example_01.c "here".
 *
 * And the code for our extension is @ref theme_example.edc "here".
 *
 * @example theme_example_01.c
 * @example theme_example.edc
 */

/**
 * @page theme_example_02 Theme - Using overlays
 *
 * @dontinclude theme_example_02.c
 *
 * Overlays are like extensions in that you tell Elementary that some other
 * theme contains the styles you need for your program. The difference is that
 * they will be look in first, so they can override the default style of any
 * widget.
 *
 * There's not much to say about them that hasn't been said in our previous
 * example about @ref theme_example_01 "extensions", so going quickly through
 * the code we have a function to load or unload the theme, which will be
 * called when we click any button.
 * @skipline Elementary.h
 * @skip static void
 * @until }
 *
 * And the main function, creating the window and adding some buttons to it.
 * We load our theme as an overlay and nothing else. Notice there's no style
 * set for any button there, which means they should be using the default
 * that we override.
 * @skip int
 * @until ELM_MAIN
 *
 * That's pretty much it. The full code is @ref theme_example_02.c "here" and
 * the definition of the theme is the same as before, and can be found in
 * @ref theme_example.edc "here".
 *
 * @example theme_example_02.c
 */

 /**
  * @page button_example_01 Button - Complete example
  *
  * @dontinclude button_example_01.c
  *
  * A button is simple, you click on it and something happens. That said,
  * we'll go through an example to show in detail the button API less
  * commonly used.
  *
  * In the end, we'll be presented with something that looks like this:
  *
  * @image html screenshots/button_01.png
  * @image latex screenshots/button_01.eps width=\textwidth
  *
  * The full code of the example is @ref button_example_01.c "here" and we
  * will follow here with a rundown of it.
  *
  * @skip Elementary.h
  * @until Elementary.h
  * @skip struct
  * @until App_Data
  *
  * We have several buttons to set different times for the autorepeat timeouts
  * of the buttons that use it and a few more that we keep track of in our
  * data struct. The mid button doesn't do much, just moves around according
  * to what other buttons the user presses. Then four more buttons to move the
  * central one, and we're also keeping track of the icon set in the middle
  * button, since when this one moves, we change the icon, and when movement
  * is finished (by releasing one of the four arrow buttons), we set back the
  * normal icon.
  * @skip static void
  * @until }
  *
  * Keeping any of those four buttons pressed will trigger their autorepeat
  * callback, where we move the button doing some size hint magic. To
  * understand how that works better, refer to the @ref Box documentation.
  * Also, the first time the function is called, we change the icon in the
  * middle button, using elm_button_icon_unset() first to keep the reference
  * to the previous one, so we don't need to recreate it when we are done
  * moving it.
  * @skip static void
  * @until }
  * @until size_hint_align_set
  * @until }
  *
  * One more callback for the option buttons, that just sets the timeouts for
  * the different autorepeat options.
  *
  * @skip static void
  * @until }
  * @until }
  * @until }
  *
  * And the main function, which does some setting up of the buttons in boxes
  * to make things work. Here we'll go through some snippets only.
  *
  * For the option buttons, it's just the button with its label and callback.
  * @skip elm_button_add
  * @until smart_callback_add
  *
  * For the ones that move the central button, we have no labels. There are
  * icons instead, and the autorepeat option is toggled.
  * @skip Gap: 1.0
  * @skip elm_button_add
  * @until data.cursors.up
  *
  * And just to show the mid button, which doesn't have anything special.
  * @skip data.cursors.left
  * @skip elm_button_add
  * @until data.mid
  *
  * And we are done.
  *
  * @example button_example_01.c
  */

/**
 * @page bubble_01_example_page elm_bubble - Simple use.
 * @dontinclude bubble_example_01.c
 *
 * This example shows a bubble with all fields set(label, info, content and
 * icon) and the selected corner changing when the bubble is clicked. To be
 * able use a bubble we need to do some setup and create a window, for this
 * example we are going to ignore that part of the code since it isn't
 * relevant to the bubble.
 *
 * To have the selected corner change in a clockwise motion we are going to
 * use the following callback:
 * @skip static
 * @until }
 * @until }
 *
 * Here we are creating an elm_label that is going to be used as the content
 * for our bubble:
 * @skipline elm_label
 * @until show
 * @note You could use any evas_object for this, we are using an elm_label
 * for simplicity.
 *
 * Despite it's name the bubble's icon doesn't have to be an icon, it can be
 * any evas_object. For this example we are going to make the icon a simple
 * blue rectangle:
 * @until show
 *
 * And finally we have the actual bubble creation and the setting of it's
 * label, info and content:
 * @until content
 * @skipline show
 * @note Because we didn't set a corner, the default("top_left") will be
 * used.
 *
 * Now that we have our bubble all that is left is connecting the "clicked"
 * signals to our callback:
 * @line smart_callback
 *
 * This last bubble we created was very complete, so it's pertinent to show
 * that most of that stuff is optional a bubble can be created with nothing
 * but content:
 * @until content
 * @skipline show
 *
 * Our example will look like this:
 *
 * @image html screenshots/bubble_example_01.png
 * @image latex screenshots/bubble_example_01.eps width=\textwidth
 *
 * See the full source code @ref bubble_example_01.c here.
 * @example bubble_example_01.c
 */

/**
 * @page box_example_01 Box - Basic API
 *
 * @dontinclude button_example_01.c
 *
 * As a special guest tonight, we have the @ref button_example_01 "simple
 * button example". There are plenty of boxes in it, and to make the cursor
 * buttons that moved a central one around when pressed, we had to use a
 * variety of values for their hints.
 *
 * To start, let's take a look at the handling of the central button when
 * we were moving it around. To achieve this effect without falling back to
 * a complete manual positioning of the @c Evas_Object in our canvas, we just
 * put it in a box and played with its alignment within it, as seen in the
 * following snippet of the callback for the pressed buttons.
 * @skip evas_object_size_hint_align_get
 * @until evas_object_size_hint_align_set
 *
 * Not much to it. We get the current alignment of the object and change it
 * by just a little, depending on which button was pressed, then set it
 * again, making sure we stay within the 0.0-1.0 range so the button moves
 * inside the space it has, instead of disappearing under the other objects.
 *
 * But as useful as an example as that may have been, the usual case with boxes
 * is to set everything at the moment they are created, like we did for
 * everything else in our main function.
 *
 * The entire layout of our program is made with boxes. We have one set as the
 * resize object for the window, which means it will always be resized with
 * the window. The weight hints set to @c EVAS_HINT_EXPAND will tell the
 * window that the box can grow past it's minimum size, which allows resizing
 * of it.
 * @skip elm_main
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Two more boxes, set to horizontal, hold the buttons to change the autorepeat
 * configuration used by the buttons. We create each to take over all the
 * available space horizontally, but we don't want them to grow vertically,
 * so we keep that axis of the weight with 0.0. Then it gets packed in the
 * main box.
 * @skip box2
 * @until evas_object_show
 *
 * The buttons in each of those boxes have nothing special, they are just packed
 * in with their default values and the box will use their minimum size, as set
 * by Elementary itself based on the label, icon, finger size and theme.
 *
 * But the buttons used to move the central one have a special disposition.
 * The top one first, is placed right into the main box like our other smaller
 * boxes. Set to expand horizontally and not vertically, and in this case we
 * also tell it to fill that space, so it gets resized to take the entire
 * width of the window.
 * @skip Gap: 1.0
 * @skip elm_button_add
 * @until evas_object_show
 *
 * The bottom one will be the same, but for the other two we need to use a
 * second box set to take as much space as we have, so we can place our side
 * buttons in place and have the big empty space where the central button will
 * move.
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Then the buttons will have their hints inverted to the other top and bottom
 * ones, to expand and fill vertically and keep their minimum size horizontally.
 * @skip elm_button_add
 * @until evas_object_show
 *
 * The central button takes every thing else. It will ask to be expanded in
 * both directions, but without filling its cell. Changing its alignment by
 * pressing the buttons will make it move around.
 * @skip elm_button_add
 * @until evas_object_show
 *
 * To end, the rightmost button is packed in the smaller box after the central
 * one, and back to the main box we have the bottom button at the end.
 */

/**
 * @page box_example_02 Box - Layout transitions
 *
 * @dontinclude box_example_02.c
 *
 * Setting a customized layout for a box is simple once you have the layout
 * function, which is just like the layout function for @c Evas_Box. The new
 * and fancier thing we can do with Elementary is animate the transition from
 * one layout to the next. We'll see now how to do that through a simple
 * example, while also taking a look at some of the API that was left
 * untouched in our @ref box_example_01 "previous example".
 *
 * @image html screenshots/box_example_02.png
 * @image latex screenshots/box_example_02.eps width=\textwidth
 *
 * @skipline Elementary.h
 *
 * Our application data consists of a list of layout functions, given by
 * @c transitions. We'll be animating through them throughout the entire run.
 * The box with the stuff to move around and the last layout that was set to
 * make things easier in the code.
 * @skip typedef
 * @until Transitions_Data
 *
 * The box starts with three buttons, clicking on any of them will take it
 * out of the box without deleting the object. There are also two more buttons
 * outside, one to add an object to the box and the other to clear it.
 * This is all to show how you can interact with the items in the box, add
 * things and even remove them, while the transitions occur.
 *
 * One of the callback we'll be using creates a new button, asks the box for
 * the list of its children and if it's not empty, we add the new object after
 * the first one, otherwise just place at the end as it will not make any
 * difference.
 * @skip static void
 * @until }
 * @until }
 *
 * The clear button is even simpler. Everything in the box will be deleted,
 * leaving it empty and ready to fill it up with more stuff.
 * @skip static void
 * @until }
 *
 * And a little function to remove buttons from the box without deleting them.
 * This one is set for the @c clicked callback of the original buttons,
 * unpacking them when clicked and placing it somewhere in the screen where
 * they will not disturb. Once we do this, the box no longer has any control
 * of it, so it will be left untouched until the program ends.
 * @skip static void
 * @until }
 *
 * If we wanted, we could just call @c evas_object_del() on the object to
 * destroy it. In this case, no unpack is really necessary, as the box would
 * be notified of a child being deleted and adjust its calculations accordingly.
 *
 * The core of the program is the following function. It takes whatever
 * function is first on our list of layouts and together with the
 * @c last_layout, it creates an ::Elm_Box_Transition to use with
 * elm_box_layout_transition(). In here, we tell it to start from whatever
 * layout we last set, end with the one that was at the top of the list and
 * when everything is finished, call us back so we can create another
 * transition. Finally, move the new layout to the end of the list so we
 * can continue running through them until the program ends.
 * @skip static void
 * @until }
 *
 * The main function doesn't have antyhing special. Creation of box, initial
 * buttons and some callback setting. The only part worth mentioning is the
 * initialization of our application data.
 * @skip tdata.box
 * @until evas_object_box_layout_stack
 *
 * We have a simple static variable, set the box, the first layout we are
 * using as last and create the list with the different functions to go
 * through.
 *
 * And in the end, we set the first layout and call the same function we went
 * through before to start the run of transitions.
 * @until _test_box_transition_change
 *
 * For the full code, follow @ref box_example_02.c "here".
 *
 * @example box_example_02.c
 */

/**
 * @page calendar_example_01 Calendar - Simple creation.
 * @dontinclude calendar_example_01.c
 *
 * As a first example, let's just display a calendar in our window,
 * explaining all steps required to do so.
 *
 * First you should declare objects we intend to use:
 * @skipline Evas_Object
 *
 * Then a window is created, a title is set and its set to be autodeleted.
 * More details can be found on windows examples:
 * @until elm_win_autodel
 *
 * Next a simple background is placed on our windows. More details on
 * @ref bg_01_example_page:
 * @until evas_object_show(bg)
 *
 * Now, the exciting part, let's add the calendar with elm_calendar_add(),
 * passing our window object as parent.
 * @until evas_object_show(cal);
 *
 * To conclude our example, we should show the window and run elm mainloop:
 * @until ELM_MAIN
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_01.png
 * @image latex screenshots/calendar_example_01.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_01.c here.
 * @example calendar_example_01.c
 */

/**
 * @page calendar_example_02 Calendar - Layout strings formatting.
 * @dontinclude calendar_example_02.c
 *
 * In this simple example, we'll explain how to format the label displaying
 * month and year, and also set weekday names.
 *
 * To format month and year label, we need to create a callback function
 * to create a string given the selected time, declared under a
 * <tt> struct tm </tt>.
 *
 * <tt> struct tm </tt>, declared on @c time.h, is a structure composed by
 * nine integers:
 * @li tm_sec   seconds [0,59]
 * @li tm_min   minutes [0,59]
 * @li tm_hour  hour [0,23]
 * @li tm_mday  day of month [1,31]
 * @li tm_mon   month of year [0,11]
 * @li tm_year  years since 1900
 * @li tm_wday  day of week [0,6] (Sunday = 0)
 * @li tm_yday  day of year [0,365]
 * @li tm_isdst daylight savings flag
 * @note glib version has 2 additional fields.
 *
 * For our function, only stuff that matters are tm_mon and tm_year.
 * But we don't need to access it directly, since there are nice functions
 * to format date and time, as @c strftime.
 * We will get abbreviated month (%b) and year (%y) (check strftime manpage
 * for more) in our example:
 * @skipline static char
 * @until }
 *
 * We need to alloc the string to be returned, and calendar widget will
 * free it when it's not needed, what is done by @c strdup.
 * So let's register our callback to calendar object:
 * @skipline elm_calendar_format_function_set
 *
 * To set weekday names, we should declare them as an array of strings:
 * @dontinclude calendar_example_02.c
 * @skipline weekdays
 * @until }
 *
 * And finally set them to calendar:
 * skipline weekdays_names_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_02.png
 * @image latex screenshots/calendar_example_02.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_02.c here.
 * @example calendar_example_02.c
 */

/**
 * @page calendar_example_03 Calendar - Years restrictions.
 * @dontinclude calendar_example_03.c
 *
 * This example explains how to set max and min year to be displayed
 * by a calendar object. This means that user won't be able to
 * see or select a date before and after selected years.
 * By default, limits are 1902 and maximun value will depends
 * on platform architecture (year 2037 for 32 bits); You can
 * read more about time functions on @c ctime manpage.
 *
 * Straigh to the point, to set it is enough to call
 * elm_calendar_min_max_year_set(). First value is minimun year, second
 * is maximum. If first value is negative, it won't apply limit for min
 * year, if the second one is negative, won't apply for max year.
 * Setting both to negative value will clear limits (default state):
 * @skipline elm_calendar_min_max_year_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_03.png
 * @image latex screenshots/calendar_example_03.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_03.c here.
 * @example calendar_example_03.c
 */

/**
 * @page calendar_example_04 Calendar - Days selection.
 * @dontinclude calendar_example_04.c
 *
 * It's possible to disable date selection and to select a date
 * from your program, and that's what we'll see on this example.
 *
 * If isn't required that users could select a day on calendar,
 * only interacting going through months, disabling days selection
 * could be a good idea to avoid confusion. For that:
 * @skipline elm_calendar_day_selection_enabled_set
 *
 * Also, regarding days selection, you could be interested to set a
 * date to be highlighted on calendar from your code, maybe when
 * a specific event happens, or after calendar creation. Let's select
 * two days from current day:
 * @dontinclude calendar_example_04.c
 * @skipline SECS_DAY
 * @skipline current_time
 * @until elm_calendar_selected_time_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_04.png
 * @image latex screenshots/calendar_example_04.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_04.c here.
 * @example calendar_example_04.c
 */

/**
 * @page calendar_example_05 Calendar - Signal callback and getters.
 * @dontinclude calendar_example_05.c
 *
 * Most of setters explained on previous examples have associated getters.
 * That's the subject of this example. We'll add a callback to display
 * all calendar information every time user interacts with the calendar.
 *
 * Let's check our callback function:
 * @skipline static void
 * @until double interval;
 *
 * To get selected day, we need to call elm_calendar_selected_time_get(),
 * but to assure nothing wrong happened, we must check for function return.
 * It'll return @c EINA_FALSE if fail. Otherwise we can use time set to
 * our structure @p stime.
 * @skipline elm_calendar_selected_time_get
 * @until return
 *
 * Next we'll get information from calendar and place on declared vars:
 * @skipline interval
 * @until elm_calendar_weekdays_names_get
 *
 * The only tricky part is that last line gets an array of strings
 * (char arrays), one for each weekday.
 *
 * Then we can simple print that to stdin:
 * @skipline printf
 * @until }
 *
 * <tt> struct tm </tt> is declared on @c time.h. You can check @c ctime
 * manpage to read about it.
 *
 * To register this callback, that will be called every time user selects
 * a day or goes to next or previous month, just add a callback for signal
 * @b changed.
 * @skipline evas_object_smart_callback_add
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_05.png
 * @image latex screenshots/calendar_example_05.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_05.c here.
 * @example calendar_example_05.c
 */

/**
 * @page calendar_example_06 Calendar - Calendar marks.
 * @dontinclude calendar_example_06.c
 *
 * On this example marks management will be explained. Functions
 * elm_calendar_mark_add(), elm_calendar_mark_del() and
 * elm_calendar_marks_clear() will be covered.
 *
 * To add a mark, will be required to choose three things:
 * @li mark style
 * @li mark date, or start date if it will be repeated
 * @li mark periodicity
 *
 * Style defines the kind of mark will be displayed over marked day,
 * on caledar. Default theme supports @b holiday and @b checked.
 * If more is required, is possible to set a new theme to calendar
 * widget using elm_object_style_set(), and use
 * the signal that will be used by such marks.
 *
 * Date is a <tt> struct tm </tt>, as defined by @c time.h. More can
 * be read on @c ctime manpage.
 * If a date relative from current is required, this struct can be set
 * as:
 * @skipline current_time
 * @until localtime_r
 *
 * Or if it's an absolute date, you can just declare the struct like:
 * @dontinclude calendar_example_06.c
 * @skipline sunday
 * @until christmas.tm_mon
 *
 * Periodicity is how frequently the mark will be displayed over the
 * calendar.  Can be a unique mark (that don't repeat), or it can repeat
 * daily, weekly, monthly or annually. It's enumerated by
 * @c Elm_Calendar_Mark_Repeat.
 *
 * So let's add some marks to our calendar. We will add christmas holiday,
 * set Sundays as holidays, and check current day and day after that.
 * @dontinclude calendar_example_06.c
 * @skipline sunday
 * @until christmas.tm_mon
 * @skipline current_time
 * @until ELM_CALENDAR_WEEKLY
 *
 * We kept the return of first mark add, because we don't really won't it
 * to be checked, so let's remove it:
 * @skipline elm_calendar_mark_del
 *
 * After all marks are added and removed, is required to draw them:
 * @skipline elm_calendar_marks_draw
 *
 * Finally, to clear all marks, let's set a callback for our button:
 * @skipline elm_button_add
 * @until evas_object_show(bt);
 *
 * This callback will receive our calendar object, and should clear it:
 * @dontinclude calendar_example_06.c
 * @skipline static
 * @until }
 * @note Remember to draw marks after clear the calendar.
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_06.png
 * @image latex screenshots/calendar_example_06.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_06.c here.
 * @example calendar_example_06.c
 */

/**
 * @page clock_example Clock widget example
 *
 * This code places five Elementary clock widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * The first of them is the pristine clock:
 * @dontinclude clock_example.c
 * @skip pristine
 * @until evas_object_show
 * As you see, the defaults for a clock are:
 * - military time
 * - no seconds shown
 *
 * For am/pm time, see the second clock:
 * @dontinclude clock_example.c
 * @skip am/pm
 * @until evas_object_show
 *
 * The third one will show the seconds digits, which will flip in
 * synchrony with system time. Note, besides, that the time itself is
 * @b different from the system's -- it was customly set with
 * elm_clock_time_set():
 * @dontinclude clock_example.c
 * @skip with seconds
 * @until evas_object_show
 *
 * In both fourth and fifth ones, we turn on the <b>edition
 * mode</b>. See how you can change each of the sheets on it, and be
 * sure to try holding the mouse pressed over one of the sheet
 * arrows. The forth one also starts with a custom time set:
 * @dontinclude clock_example.c
 * @skip in edition
 * @until evas_object_show
 *
 * The fifth, besides editable, has only the time @b units editable,
 * for hours, minutes and seconds. This exemplifies
 * elm_clock_digit_edit_set():
 * @dontinclude clock_example.c
 * @skip but only
 * @until evas_object_show
 *
 * See the full @ref clock_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/clock_example.png
 * @image latex screenshots/clock_example.eps width=\textwidth
 *
 * See the full @ref clock_example_c "source code" for this example.
 *
 * @example clock_example.c
 */

/**
 * @page diskselector_example_01 Diskselector widget example
 *
 * This code places 4 Elementary diskselector widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * All of them will have weekdays as items, since we won't focus
 * on items management on this example. For an example about this subject,
 * check @ref diskselector_example_02.
 *
 * The first of them is a default diskselector.
 * @dontinclude diskselector_example_01.c
 * @skipline lbl
 * @until }
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * We are just adding the diskselector, so as you can see, defaults for it are:
 * @li Only 3 items visible each time.
 * @li Only 3 characters are displayed for labels on side positions.
 * @li The first added item remains centeres, i.e., it's the selected item.
 *
 * To add items, we are just appending it on a loop, using function
 * elm_diskselector_item_append(), that will be better exaplained on
 * items management example.
 *
 * For a circular diskselector, check the second widget. A circular
 * diskselector will display first item after last, and last previous to
 * the first one. So, as you can see, @b Sa will appears on left side
 * of selected @b Sunday. This property is set with
 * elm_diskselector_round_set().
 *
 * Also, we decide to display only 2 character for side labels, instead of 3.
 * For this we call elm_diskselector_side_label_length_set(). As result,
 * we'll see @b Mo displayed instead of @b Mon, when @b Monday is on a
 * side position.
 *
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * But so far, we are only displaying 3 items at once. If more are wanted,
 * is enough to call elm_diskselector_display_item_num_set(), as you can
 * see here:
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * @note You can't set less than 3 items to be displayed.
 *
 * Finally, if a bounce effect is required, or you would like to see
 * scrollbars, it is possible. But, for default theme, diskselector
 * scrollbars will be invisible anyway.
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * See the full @ref diskselector_example_01.c "diskselector_example_01.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/diskselector_example_01.png
 * @image latex screenshots/diskselector_example_01.eps width=\textwidth
 *
 * @example diskselector_example_01.c
 */

/**
 * @page diskselector_example_02 Diskselector - Items management
 *
 * This code places a Elementary diskselector widgets on a window,
 * along with some buttons trigerring actions on it (though its API).
 * It covers most of Elm_Diskselector_Item functions.
 *
 * On our @c main function, we are adding a default diskselector with
 * 3 items. We are only setting their labels (second parameter of function
 * elm_diskselector_item_append):
 * @dontinclude diskselector_example_02.c
 * @skipline elm_diskselector_add
 * @until Item 2
 *
 * Next we are adding lots of buttons, each one for a callback function
 * that will realize a task covering part of diskselector items API.
 * Lets check the first one:
 * @skipline elm_button_add
 * @until evas_object_show
 *
 * We are labeling the button with a task description with
 * elm_object_text_set() and setting a callback
 * function evas_object_smart_callback_add().
 * Each callback function will have the signature:
 * <tt> static void _task_cb(void *data, Evas_Object *obj,
 * void *event_info)</tt> with the function name varying for each task.
 *
 * Now let's cover all of them.
 *
 * <b> Appending an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _add_cb
 * @until }
 *
 * All items are included on diskselector after last one. You @b can't
 * preprend items.
 *
 * The first parameter of elm_diskselector_item_append() is the diskselector
 * object, that we are receiving as data on our callback function.
 * The second one is a label, the string that will be placed in the center
 * of our item. As we don't wan't icons or callback functions, we can
 * send NULL as third, fourth and fifth parameters.
 *
 * <b> Appending an item with icon: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _add_ic_cb
 * @until }
 *
 * If an icon is required, you can pass it as third paramenter on our
 * elm_diskselector_item_append() function. It will be place on the
 * left side of item's label, that will be shifted to right a bit.
 *
 * For more details about how to create icons, look for elm_icon examples.
 *
 * <b> Appending an item with callback function for selected: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _sel_cb
 * @until }
 * @until }
 *
 * To set a callback function that will be called every time an item is
 * selected, i.e., everytime the diskselector stops with this item in
 * center position, just pass the function as fourth paramenter.
 *
 * <b> Appending an item with callback function for selected with data: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _sel_data_cb
 * @until }
 * @until }
 * @until }
 * @until }
 *
 * If the callback function request an extra data, it can be attached to our
 * item passing a pointer for data as fifth parameter.
 * Our function _sel_data_cb will receive it as <tt> void *data </tt>.
 *
 * If you want to free this data, or handle that the way you need when the
 * item is deleted, set a callback function for that, with
 * elm_diskselector_item_del_cb_set().
 *
 * As you can see we check if @c it is not @c NULL after appending it.
 * If an error happens, we won't try to set a function for it.
 *
 * <b> Deleting an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skip _del_cb
 * @skipline _del_cb
 * @until }
 *
 * To delete an item we simple need to call elm_diskselector_item_del() with
 * a pointer for such item.
 *
 * If you need, you can get selected item with
 * elm_diskselector_selected_item_get(), that will return a pointer for it.
 *
 * <b> Unselecting an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _unselect_cb
 * @until }
 *
 * To select an item, you should call elm_diskselector_item_selected_set()
 * passing @c EINA_TRUE, and to unselect it, @c EINA_FALSE.
 *
 * If you unselect the selected item, diskselector will automatically select
 * the first item.
 *
 * <b> Printing all items: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _print_cb
 * @until }
 *
 * <b> Clearing the diskselector: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _clear_cb
 * @until }
 *
 * <b> Selecting the first item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_first_cb
 * @until }
 *
 * <b> Selecting the last item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_last_cb
 * @until }
 *
 * <b> Selecting the next item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_next_cb
 * @until }
 *
 * <b> Selecting the previous item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_prev_cb
 * @until }
 *
 * See the full @ref diskselector_example_02.c "diskselector_example_02.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/diskselector_example_02.png
 * @image latex screenshots/diskselector_example_02.eps width=\textwidth
 *
 * @example diskselector_example_02.c
 */

/**
 * @page flipselector_example Flip selector widget example
 *
 * This code places an Elementary flip selector widget on a window,
 * along with two buttons trigerring actions on it (though its API).
 *
 * The selector is being populated with the following items:
 * @dontinclude flipselector_example.c
 * @skip lbl[]
 * @until ;
 *
 * Next, we create it, populating it with those items and registering
 * two (smart) callbacks on it:
 * @dontinclude flipselector_example.c
 * @skip fp = elm_flipselector_add
 * @until object_show
 *
 * Those two callbacks will take place whenever one of those smart
 * events occur, and they will just print something to @c stdout:
 * @dontinclude flipselector_example.c
 * @skip underflow callback
 * @until static void
 * Flip the sheets on the widget while looking at the items list, in
 * the source code, and you'll get the idea of those events.
 *
 * The two buttons below the flip selector will take the actions
 * described in their labels:
 * @dontinclude flipselector_example.c
 * @skip bt = elm_button_add
 * @until callback_add(win
 *
 * @dontinclude flipselector_example.c
 * @skip unselect the item
 * @until underflow
 *
 * Click on them to exercise those flip selector API calls. To
 * interact with the other parts of this API, there's a command line
 * interface, whose help string can be asked for with the 'h' key:
 * @dontinclude flipselector_example.c
 * @skip commands
 * @until ;
 *
 * The 'n' and 'p' keys will exemplify elm_flipselector_flip_next()
 * and elm_flipselector_flip_prev(), respectively. 'f' and 'l' account
 * for elm_flipselector_first_item_get() and
 * elm_flipselector_last_item_get(), respectively. Finally, 's' will
 * issue elm_flipselector_selected_item_get() on our example flip
 * selector widget.
 *
 * See the full @ref flipselector_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/flipselector_example.png
 * @image latex screenshots/flipselector_example.eps width=\textwidth
 *
 * See the full @ref flipselector_example_c "source code" for this example.
 *
 * @example flipselector_example.c
 */

/**
 * @page fileselector_example File selector widget example
 *
 * This code places two Elementary file selector widgets on a window.
 * The one on the left is layouting file system items in a @b list,
 * while the the other is layouting them in a @b grid.
 *
 * The one having the majority of hooks of interest is on the left,
 * which we create as follows:
 * @dontinclude fileselector_example.c
 * @skip first file selector
 * @until object_show
 *
 * Note that we enable custom edition of file/directory selection, via
 * the text entry it has on its bottom, via
 * elm_fileselector_is_save_set(). It starts with the list view, which
 * is the default, and we make it not expandable in place
 * (elm_fileselector_expandable_set()), so that it replaces its view's
 * contents with the current directory's entries each time one
 * navigates to a different folder.  For both of file selectors we are
 * starting to list the contents found in the @c "/tmp" directory
 * (elm_fileselector_path_set()).
 *
 * Note the code setting it to "grid mode" and observe the differences
 * in the file selector's views, in the example. We also hide the
 * second file selector's Ok/Cancel buttons -- since it's there just
 * to show the grid view (and navigation) -- via
 * elm_fileselector_buttons_ok_cancel_set().
 *
 * The @c "done" event, which triggers the callback below
 * @dontinclude fileselector_example.c
 * @skip 'done' cb
 * @until }
 * will be called at the time one clicks the "Ok"/"Cancel" buttons of
 * the file selector (on the left). Note that it will print the path
 * to the current selection, if any.
 *
 * The @c "selected" event, which triggers the callback below
 * @dontinclude fileselector_example.c
 * @skip bt = 'selected' cb
 * @until }
 * takes place when one selects a file (if the file selector is @b not
 * under folders-only mode) or when one selects a folder (when in
 * folders-only mode). Experiment it by selecting different file
 * system entries.
 *
 * What comes next is the code creating the three check boxes and two
 * buttons below the file selector in the right. They will exercise a
 * bunch of functions on the file selector's API, for the instance on
 * the left. Experiment with them, specially the buttons, to get the
 * difference between elm_fileselector_path_get() and
 * elm_fileselector_selected_get().
 *
 * Finally, there's the code adding the second file selector, on the
 * right:
 * @dontinclude fileselector_example.c
 * @skip second file selector
 * @until object_show
 *
 * Pay attention to the code setting it to "grid mode" and observe the
 * differences in the file selector's views, in the example. We also
 * hide the second file selector's Ok/Cancel buttons -- since it's
 * there just to show the grid view (and navigation) -- via
 * elm_fileselector_buttons_ok_cancel_set().
 *
 * See the full @ref fileselector_example.c "example", whose window
 * should look like this picture:
 *
 * @image html screenshots/fileselector_example.png
 * @image latex screenshots/fileselector_example.eps width=\textwidth
 *
 * See the full @ref fileselector_example_c "source code" for this example.
 *
 * @example fileselector_example.c
 */

/**
 * @page fileselector_button_example File selector button widget example
 *
 * This code places an Elementary file selector button widget on a
 * window, along with some other checkboxes and a text entry. Those
 * are there just as knobs on the file selector button's state and to
 * display information from it.
 *
 * Here's how we instantiate it:
 * @dontinclude fileselector_button_example.c
 * @skip ic = elm_icon_add
 * @until evas_object_show
 *
 * Note that we set on it both icon and label decorations. It's set to
 * list the contents of the @c "/tmp" directory, too, with
 * elm_fileselector_button_path_set(). What follows are checkboxes to
 * exercise some of its API funtions:
 * @dontinclude fileselector_button_example.c
 * @skip ck = elm_check_add
 * @until evas_object_show(en)
 *
 * The checkboxes will toggle whether the file selector button's
 * internal file selector:
 * - must have an editable text entry for file names (thus, be in
 *   "save dialog mode")
 * - is to be raised as an "inner window" (note it's the default
 *   behavior) or as a dedicated window
 * - is to populate its view with folders only
 * - is to expand its folders, in its view, <b>in place</b>, and not
 *   repainting it entirely just with the contents of a sole
 *   directory.
 *
 * The entry labeled @c "Last selection" will exercise the @c
 * "file,chosen" smart event coming from the file selector button:
 * @dontinclude fileselector_button_example.c
 * @skip hook on the
 * @until toggle inwin
 *
 * Whenever you dismiss or acknowledges the file selector, after it's
 * raised, the @c event_info string will contain the last selection on
 * it (if any was made).
 *
 * This is how the example, just after called, should look like:
 *
 * @image html screenshots/fileselector_button_example_00.png
 * @image latex screenshots/fileselector_button_example_00.eps width=\textwidth
 *
 * Click on the file selector button to raise its internal file
 * selector, which will be contained on an <b>"inner window"</b>:
 *
 * @image html screenshots/fileselector_button_example_01.png
 * @image latex screenshots/fileselector_button_example_01.eps width=\textwidth
 *
 * Toggle the "inwin mode" switch off and, if you click on the file
 * selector button again, you'll get @b two windows, the original one
 * (note the last selection there!)
 *
 * @image html screenshots/fileselector_button_example_02.png
 * @image latex screenshots/fileselector_button_example_02.eps width=\textwidth
 *
 * and the file selector's new one
 *
 * @image html screenshots/fileselector_button_example_03.png
 * @image latex screenshots/fileselector_button_example_03.eps width=\textwidth
 *
 * Play with the checkboxes to get the behavior changes on the file
 * selector button. The respective API calls on the widget coming from
 * those knobs where shown in the code already.
 *
 * See the full @ref fileselector_button_example_c "source code" for
 * this example.
 *
 * @example fileselector_button_example.c
 */

/**
 * @page fileselector_entry_example File selector entry widget example
 *
 * This code places an Elementary file selector entry widget on a
 * window, along with some other checkboxes. Those are there just as
 * knobs on the file selector entry's state.
 *
 * Here's how we instantiate it:
 * @dontinclude fileselector_entry_example.c
 * @skip ic = elm_icon_add
 * @until evas_object_show
 *
 * Note that we set on it's button both icon and label
 * decorations. It's set to exhibit the path of (and list the contents
 * of, when internal file selector is launched) the @c "/tmp"
 * directory, also, with elm_fileselector_entry_path_set(). What
 * follows are checkboxes to exercise some of its API funtions:
 * @dontinclude fileselector_entry_example.c
 * @skip ck = elm_check_add
 * @until callback_add(fs_entry
 *
 * The checkboxes will toggle whether the file selector entry's
 * internal file selector:
 * - must have an editable text entry for file names (thus, be in
 *   "save dialog mode")
 * - is to be raised as an "inner window" (note it's the default
 *   behavior) or as a dedicated window
 * - is to populate its view with folders only
 * - is to expand its folders, in its view, <b>in place</b>, and not
 *   repainting it entirely just with the contents of a sole
 *   directory.
 *
 * Observe how the entry's text will match the string coming from the
 * @c "file,chosen" smart event:
 * @dontinclude fileselector_entry_example.c
 * @skip hook on the
 * @until }
 * Whenever you dismiss or acknowledges the file selector, after it's
 * raised, the @c event_info string will contain the last selection on
 * it (if any was made).
 *
 * Try, also, to type in a valid system path and, then, open the file
 * selector's window: it will start the file browsing there, for you.
 *
 * This is how the example, just after called, should look like:
 *
 * @image html screenshots/fileselector_entry_example_00.png
 * @image latex screenshots/fileselector_entry_example_00.eps width=\textwidth
 *
 * Click on the file selector entry to raise its internal file
 * selector, which will be contained on an <b>"inner window"</b>:
 *
 * @image html screenshots/fileselector_entry_example_01.png
 * @image latex screenshots/fileselector_entry_example_01.eps width=\textwidth
 *
 * Toggle the "inwin mode" switch off and, if you click on the file
 * selector entry again, you'll get @b two windows, the original one
 * (note the last selection there!)
 *
 * @image html screenshots/fileselector_entry_example_02.png
 * @image latex screenshots/fileselector_entry_example_02.eps width=\textwidth
 *
 * and the file selector's new one
 *
 * @image html screenshots/fileselector_entry_example_03.png
 * @image latex screenshots/fileselector_entry_example_03.eps width=\textwidth
 *
 * Play with the checkboxes to get the behavior changes on the file
 * selector entry. The respective API calls on the widget coming from
 * those knobs where shown in the code already.
 *
 * See the full @ref fileselector_entry_example_c "source code" for
 * this example.
 *
 * @example fileselector_entry_example.c
 */

/**
 * @page layout_example_01 Layout - Content, Table and Box
 *
 * This example shows how one can use the @ref Layout widget to create a
 * customized distribution of widgets on the screen, controled by an Edje theme.
 * The full source code for this example can be found at @ref
 * layout_example_01_c.
 *
 * Our custom layout is defined by a file, @ref layout_example_edc, which is an
 * Edje theme file. Look for the Edje documentation to understand it. For now,
 * it's enough to know that we describe some specific parts on this layout
 * theme:
 * @li a title text field;
 * @li a box container;
 * @li a table container;
 * @li and a content container.
 *
 * Going straight to the code, the following snippet instantiates the layout
 * widget:
 *
 * @dontinclude layout_example_01.c
 * @skip elm_layout_add
 * @until evas_object_show(layout)
 *
 * As any other widget, we set some properties for the size calculation. But
 * notice on this piece of code the call to the function elm_layout_file_set().
 * Here is where the theme file is loaded, and particularly the specific group
 * from this theme file. Also notice that the theme file here is referenced as
 * an .edj, which is a .edc theme file compiled to its binary form. Again, look
 * for the Edje documentation for more information about theme files.
 *
 * Next, we fetch from our theme a data string referenced by the key "title".
 * This data was defined in the theme, and can be used as parameters which the
 * program get from the specific theme that it is using. In this case, we store
 * the title of this window and program in the theme, as a "data" entry, just
 * for demonstration purposes:
 *
 * @until }
 *
 * This call elm_layout_data_get() is used to fetch the string based on the key,
 * and elm_object_text_part_set() will set the part defined in the theme as
 * "example/title" to contain this string. This key "example/title" has nothing
 * special. It's just an arbitrary convention that we are using in this example.
 * Every string in this example referencing a part of this theme will be of the
 * form "example/<something>".
 *
 * Now let's start using our layout to distribute things on the window space.
 * Since the layout was added as a resize object to the elementary window, it
 * will always occupy the entire space available for this window.
 *
 * The theme already has a title, and it also defines a table element which is
 * positioned approximately between 50% and 70% of the height of this window,
 * and has 100% of the width. We create some widgets (two icons, a clock and a
 * button) and pack them inside the table, in a distribution similar to a HTML
 * table:
 *
 * @until evas_object_show(bt)
 *
 * Notice that we just set size hints for every object, and call the function
 * elm_layout_table_pack(), which does all the work. It will place the elements
 * in the specified row/column, with row and column span if required, and then
 * the object's size and position will be controled by the layout widget. It
 * will also respect size hints, alignments and weight properties set to these
 * widgets. The resulting distribution on the screen depends on the table
 * properties (described in the theme), the size hints set on each widget, and
 * on the cells of the table that are being used.
 *
 * For instance, we add the two icons and the clock on the first, second and
 * third cells of the first row, and add the button the second row, making it
 * span for 3 columns (thus having the size of the entire table width). This
 * will result in a table that has 2 rows and 3 columns.
 *
 * Now let's add some widgets to the box area of our layout. This box is around
 * 20% and 50% of the vertical size of the layout, and 100% of its width. The
 * theme defines that it will use an "horizontal flow" distribution to its
 * elements. Unlike the table, a box will distribute elements without knowing
 * about rows and columns, and the distribution function selected will take care
 * of putting them in row, column, both, or any other available layout. This is
 * also described in the Edje documentation.
 *
 * This box area is similar to the @ref Box widget of elementary, with the
 * difference that its position and properties are controled by the theme of the
 * layout. It also contains more than one API to add items to it, since the
 * items position now is defined in terms of a list of items, not a matrix.
 * There's the first position (can have items added to it with
 * elm_layout_box_prepend()), the last position (elm_layout_box_append()), the
 * nth position (elm_layout_box_insert_at()) and the position right before an
 * element (elm_layout_box_insert_before()). We use insert_at and prepend
 * functions to add the first two buttons to this box, and insert_before on the
 * callback of each button. The callback code will be shown later, but it
 * basically adds a button just before the clicked button using the
 * elm_layout_box_insert_before() function. Here's the code for adding the first
 * 2 buttons:
 *
 * @until evas_object_show(item)
 * @until evas_object_show(item)
 *
 * Finally, we have an area in this layout theme, in the bottom part of it,
 * reserved for adding an specific widget. Differently from the 2 parts
 * described until now, this one can only receive one widget with the call
 * elm_layout_content_set(). If there was already an item on this specific part,
 * it will be deleted (one can use elm_layout_content_unset() in order to remove
 * it without deleting). An example of removing it without deleting, but
 * manually deleting this widget just after that, can be seen on the callback
 * for this button. Actually, the callback defined for this button will clean
 * the two other parts (deleting all of their elements) and then remove and
 * delete this button.
 *
 * @until _swallow_btn_cb
 *
 * Also notice that, for this last added button, we don't have to call
 * evas_object_show() on it. This is a particularity of the theme for layouts,
 * that will have total control over the properties like size, position,
 * visibility and clipping of a widget added with elm_layout_content_set().
 * Again, read the Edje documentation to understand this better.
 *
 * Now we just put the code for the different callbacks specified for each kind
 * of button and make simple comments about them:
 *
 * @dontinclude layout_example_01.c
 * @skip static void
 * @until evas_object_del(item)
 * @until }
 *
 * The first callback is used for the button in the table, and will just remove
 * itself from the table with elm_layout_table_unpack(), which remove items
 * without deleting them, and then calling evas_object_del() on itself.
 *
 * The second callback is for buttons added to the box. When clicked, these
 * buttons will create a new button, and add them to the same box, in the
 * position just before the clicked button.
 *
 * And the last callback is for the button added to the "content" area. It will
 * clear both the table and the box, passing @c EINA_TRUE to their respective @c
 * clear parameters, which will imply on the items of these containers being
 * deleted.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_01.png
 * @image latex screenshots/layout_example_01.eps width=\textwidth
 *
 */

/**
 * @page layout_example_02 Layout - Predefined Layout
 *
 * This example shows how one can use the @ref Layout with a predefined theme
 * layout to add a back and next button to a simple window. The full source code
 * for this example can be found at @ref layout_example_02_c.
 *
 * After setting up the window and background, we add the layout widget to the
 * window. But instead of using elm_layout_file_set() to load its theme from a
 * custom theme file, we can use elm_layout_theme_set() to load one of the
 * predefined layouts that come with elementary. Particularly on this example,
 * we load the them of class "layout", group "application" and style
 * "content-back-next" (since we want the back and next buttons).
 *
 * @dontinclude layout_example_02.c
 * @skip elm_layout_add
 * @until evas_object_show(layout)
 *
 * This default theme contains only a "content" area named
 * "elm.swallow.content", where we can add any widget (it can be even a
 * container widget, like a box, frame, list, or even another layout). Since we
 * just want to show the resulting layout, we add a simple icon to it:
 *
 * @until layout_content_set
 *
 * This default layout also provides some signals when the next and prev buttons
 * are clicked. We can register callbacks to them with the
 * elm_object_signal_callback_add() function:
 *
 * @until elm,action,next
 *
 * In the @ref layout_example_03 you can see how to send signals to the layout with
 * elm_object_signal_emit().
 *
 * Now our callback just changes the picture being displayed when one of the
 * buttons are clicked:
 *
 * @dontinclude layout_example_02.c
 * @skip images
 * @until standard_set
 * @until }
 *
 * It's possible to see that it gets the name of the image being shown from the
 * array of image names, going forward on this array when "next" is clicked and
 * backward when "back" is clicked.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_02.png
 * @image latex screenshots/layout_example_02.eps width=\textwidth
 */

/**
 * @page layout_example_03 Layout - Signals and Size Changed
 *
 * This example shows how one can send and receive signals to/from the layout,
 * and what to do when the layout theme has its size changed. The full source
 * code for this example can be found at @ref layout_example_03_c.
 *
 * In this exmaple we will use another group from the same layout theme file
 * used in @ref layout_example_01. Its instanciation and loading happens in the
 * following lines:
 *
 * @dontinclude layout_example_03.c
 * @skip elm_layout_add
 * @until evas_object_show
 *
 * This time we register a callback to be called whenever we receive a signal
 * after the end of the animation that happens in this layout:
 *
 * @until signal_callback_add
 *
 * We also add a button that will send signals to the layout:
 *
 * @until callback_add
 *
 * The callback for this button will check what type of signal it should send,
 * and then emit it. The code for this callback follows:
 *
 * @dontinclude layout_exmaple_03.c
 * @skip static Eina_Bool
 * @until Enlarge
 * @until }
 * @until }
 *
 * As we said before, we are receiving a signal whenever the animation started
 * by the button click ends. This is the callback for that signal:
 *
 * @until }
 *
 * Notice from this callback that the elm_layout_sizing_eval() function must be
 * called if we want our widget to update its size after the layout theme having
 * changed its minimum size. This happens because the animation specified in the
 * theme increases the size of the content area to a value higher than the
 * widget size, thus requiring more space. But the elementary layout widget
 * has no way to know this, thus needing the elm_layout_sizing_eval() to
 * be called on the layout, informing that this size has changed.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_03.png
 * @image latex screenshots/layout_example_03.eps width=\textwidth
 */

/**
 * @page tutorial_hover Hover example
 * @dontinclude hover_example_01.c
 *
 * On this example we are going to have a button that when clicked will show our
 * hover widget, this hover will have content set on it's left, top, right and
 * middle positions. In the middle position we are placing a button that when
 * clicked will hide the hover. We are also going to use a non-default theme
 * for our hover. We won't explain the functioning of button for that see @ref
 * Button.
 *
 * We start our example with a couple of callbacks that show and hide the data
 * they're given(which we'll see later on is the hover widget):
 * @skip static
 * @until }
 * @until }
 *
 * In our main function we'll do some initialization and then create 3
 * rectangles, one red, one green and one blue to use in our hover. We'll also
 * create the 2 buttons that will show and hide the hover:
 * @until show(bt2)
 *
 * With all of that squared away we can now get to the heart of the matter,
 * creating our hover widget, which is easy as pie:
 * @until hover
 *
 * Having created our hover we now need to set the parent and target. Which if
 * you recall from the function documentations are going to tell the hover which
 * area it should cover and where it should be centered:
 * @until bt
 *
 * Now we set the theme for our hover. We're using the popout theme which gives
 * our contents a white background and causes their appearance to be animated:
 * @until popout
 *
 * And finally we set the content for our positions:
 * @until bt2
 *
 * So far so good? Great 'cause that's all there is too it, what is left now is
 * just connecting our buttons to the callbacks we defined at the beginning of
 * the example and run the main loop:
 * @until ELM_MAIN
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/hover_example_01.png
 * @image latex screenshots/hover_example_01.eps width=\textwidth
 *
 * And after you click the "Show hover" button it will look like this:
 *
 * @image html screenshots/hover_example_01_a.png
 * @image latex screenshots/hover_example_01_a.eps width=\textwidth
 *
 * @example hover_example_01.c
 */

/**
  * @page tutorial_flip Flip example
  * @dontinclude flip_example_01.c
  *
  * This example will show a flip with two rectangles on it(one blue, one
  * green). Our example will allow the user to choose the animation the flip
  * uses and to interact with it. To allow the user to choose the interaction
  * mode we use radio buttons, we will however not explain them, if you would
  * like to know more about radio buttons see @ref radio.
  *
  * We start our example with the usual setup and then create the 2 rectangles
  * we will use in our flip:
  * @until show(rect2)
  *
  * The next thing to do is to create our flip and set it's front and back
  * content:
  * @until show
  *
  * The next thing we do is set the interaction mode(which the user can later
  * change) to the page animation:
  * @until PAGE
  *
  * Setting a interaction mode however is not sufficient, we also need to
  * choose which directions we allow interaction from, for this example we
  * will use all of them:
  * @until RIGHT
  *
  * We are also going to set the hitsize to the entire flip(in all directions)
  * to make our flip very easy to interact with:
  * @until RIGHT
  *
  * After that we create our radio buttons and start the main loop:
  * @until ELM_MAIN()
  *
  * When the user clicks a radio button a function that changes the
  * interaction mode and animates the flip is called:
  * @until }
  * @note The elm_flip_go() call here serves no purpose other than to
  * ilustrate that it's possible to animate the flip programmatically.
  *
  * Our example will look like this:
  *
  * @image html screenshots/flip_example_01.png
  * @image latex screenshots/flip_example_01.eps width=\textwidth
  *
  * @note Since this is an animated example the screenshot doesn't do it
  * justice, it is a good idea to compile it and see the animations.
  *
  * @example flip_example_01.c
  */

 /**
  * @page tutorial_label Label example
  * @dontinclude label_example_01.c
  *
  * In this example we are going to create 6 labels, set some properties on
  * them and see what changes in appearance those properties cause.
  *
  * We start with the setup code that by now you should be familiar with:
  * @until show(bg)
  *
  * For our first label we have a moderately long text(that doesn't fit in the
  * label's width) so we will make it a sliding label. Since the text isn't
  * too long we don't need the animation to be very long, 3 seconds should
  * give us a nice speed:
  * @until show(label
  *
  * For our second label we have the same text, but this time we aren't going
  * to have it slide, we're going to ellipsize it. Because we ask our label
  * widget to ellipsize the text it will first diminsh the fontsize so that it
  * can show as much of the text as possible:
  * @until show(label
  *
  * For the third label we are going to ellipsize the text again, however this
  * time to make sure the fontsize isn't diminshed we will set a line wrap.
  * The wrap won't actually cause a line break because we set the label to
  * ellipsize:
  * @until show(label
  *
  * For our fourth label we will set line wrapping but won't set ellipsis, so
  * that our text will indeed be wrapped instead of ellipsized. For this label
  * we choose character wrap:
  * @until show(label
  *
  * Just two more, for our fifth label we do the same as for the fourth
  * except we set the wrap to word:
  * @until show(label
  *
  * And last but not least for our sixth label we set the style to "marker" and
  * the color to red(the default color is white which would be hard to see on
  * our white background):
  * @until show(label
  *
  * Our example will look like this:
  *
  * @image html screenshots/label_example_01.png
  * @image latex screenshots/label_example_01.eps width=\textwidth
  *
  * @example label_example_01.c
  */

 /**
  * @page tutorial_image Image example
  * @dontinclude image_example_01.c
  *
  * This example is as simple as possible. An image object will be added to the
  * window over a white background, and set to be resizeable together with the
  * window. All the options set through the example will affect the behavior of
  * this image.
  *
  * We start with the code for creating a window and its background, and also
  * add the code to write the path to the image that will be loaded:
  *
  * @skip int
  * @until snprintf
  *
  * Now we create the image object, and set that file to be loaded:
  *
  * @until }
  *
  * We can now go setting our options.
  *
  * elm_image_no_scale_set() is used just to set this value to true (we
  * don't want to scale our image anyway, just resize it).
  *
  * elm_image_scale_set() is used to allow the image to be resized to a size
  * smaller than the original one, but not to a size bigger than it.
  *
  * elm_elm_image_smooth_set() will disable the smooth scaling, so the scale
  * algorithm used to scale the image to the new object size is going to be
  * faster, but with a lower quality.
  *
  * elm_image_orient_set() is used to flip the image around the (1, 0) (0, 1)
  * diagonal.
  *
  * elm_image_aspect_ratio_retained_set() is used to keep the original aspect
  * ratio of the image, even when the window is resized to another aspect ratio.
  *
  * elm_image_fill_outside_set() is used to ensure that the image will fill the
  * entire area available to it, even if keeping the aspect ratio. The image
  * will overflow its width or height (any of them that is necessary) to the
  * object area, instead of resizing the image down until it can fit entirely in
  * this area.
  *
  * elm_image_editable_set() is used just to cover the API, but won't affect
  * this example since we are not using any copy & paste property.
  *
  * This is the code for setting these options:
  *
  * @until editable
  *
  * Now some last touches in our object size hints, window and background, to
  * display this image properly:
  *
  * @until ELM_MAIN
  *
  * This example will look like this:
  *
  * @image html screenshots/image_example_01.png
  * @image latex screenshots/image_example_01.eps width=\textwidth
  *
  * @example image_example_01.c
  */

 /**
  * @page tutorial_icon Icon example
  * @dontinclude icon_example_01.c
  *
  * This example is as simple as possible. An icon object will be added to the
  * window over a white background, and set to be resizeable together with the
  * window. All the options set through the example will affect the behavior of
  * this icon.
  *
  * We start with the code for creating a window and its background:
  *
  * @skip int
  * @until show(bg)
  *
  * Now we create the icon object, and set lookup order of the icon, and choose
  * the "home" icon:
  *
  * @until home
  *
  * An intersting thing is that after setting this, it's possible to check where
  * in the filesystem is the theme used by this icon, and the name of the group
  * used:
  *
  * @until printf
  *
  * We can now go setting our options.
  *
  * elm_icon_no_scale_set() is used just to set this value to true (we
  * don't want to scale our icon anyway, just resize it).
  *
  * elm_icon_scale_set() is used to allow the icon to be resized to a size
  * smaller than the original one, but not to a size bigger than it.
  *
  * elm_elm_icon_smooth_set() will disable the smooth scaling, so the scale
  * algorithm used to scale the icon to the new object size is going to be
  * faster, but with a lower quality.
  *
  * elm_icon_fill_outside_set() is used to ensure that the icon will fill the
  * entire area available to it, even if keeping the aspect ratio. The icon
  * will overflow its width or height (any of them that is necessary) to the
  * object area, instead of resizing the icon down until it can fit entirely in
  * this area.
  *
  * This is the code for setting these options:
  *
  * @until fill_outside
  *
  * However, if you try this example you may notice that this image is not being
  * affected by all of these options. This happens because the used icon will be
  * from elementary theme, and thus it has its own set of options like smooth
  * scaling and fill_outside options. You can change the "home" icon to use some
  * image (from your system) and see that then those options will be respected.
  *
  * Now some last touches in our object size hints, window and background, to
  * display this icon properly:
  *
  * @until ELM_MAIN
  *
  * This example will look like this:
  *
  * @image html screenshots/icon_example_01.png
  * @image latex screenshots/icon_example_01.eps width=\textwidth
  *
  * @example icon_example_01.c
  */

/**
 * @page tutorial_hoversel Hoversel example
 * @dontinclude hoversel_example_01.c
 *
 * In this example we will create a hoversel with 3 items, one with a label but
 * no icon and two with both a label and an icon. Every item that is clicked
 * will be deleted, but everytime the hoversel is activated we will also add an
 * item. In addition our first item will print all items when clicked and our
 * third item will clear all items in the hoversel.
 *
 * We will start with the normal creation of window stuff:
 * @until show(bg)
 *
 * Next we will create a red rectangle to use as the icon of our hoversel:
 * @until show
 *
 * And now we create our hoversel and set some of it's properties. We set @p win
 * as its parent, ask it to not be horizontal(be vertical) and give it a label
 * and icon:
 * @until icon_set
 *
 * Next we will add our three items, setting a callback to be called for the
 * first and third:
 * @until _rm_items
 *
 * We also set a pair of callbacks to be called whenever any item is selected or
 * when the hoversel is activated:
 * @until clicked
 *
 * And then ask that our hoversel be shown and run the main loop:
 * @until ELM_MAIN
 *
 * We now have the callback for our first item which prints all items in the
 * hoversel:
 * @until }
 *
 * Next we have the callback for our third item which removes all items from the
 * hoversel:
 * @until }
 *
 * Next we have the callback that is called whenever an item is clicked and
 * deletes that item:
 * @until }
 *
 * And the callback that is called when the hoversel is activated and adds an
 * item to the hoversel. Note that since we allocate memory for the item we need
 * to know when the item dies so we can free that memory:
 * @until }
 *
 * And finally the callback that frees the memory we allocated for items created
 * in the @p _add_item callback:
 * @until }
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/hoversel_example_01.png
 * @image latex screenshots/hoversel_example_01.eps width=\textwidth
 *
 * And when the hoversel is clicked it will look like this:
 *
 * @image html screenshots/hoversel_example_01_a.png
 * @image latex screenshots/hoversel_example_01_a.eps width=\textwidth
 *
 * @example hoversel_example_01.c
 */

/**
 * @page conformant_example Conformant Example.
 *
 * In this example we'll explain how to create applications to work
 * with illume, considering space required for virtual keyboards.
 *
 * Illume is a module for Enlightenment that modifies the user interface
 * to work cleanly and nicely on a mobile device. It has support for
 * virtual keyboard, among other nice features.
 *
 * Let's start creating a very simple window with a vertical box
 * with multi-line entry between two buttons.
 * This entry will expand filling all space on window not used by buttons.
 *
 * @dontinclude conformant_example_01.c
 * @skipline elm_main
 * @until }
 *
 * For information about how to create windows, boxes, buttons or entries,
 * look for documentation for these widgets.
 *
 * It will looks fine when you don't need a virtual keyboard, as you
 * can see on the following image:
 *
 * @image html screenshots/conformant_example_01.png
 * @image latex screenshots/conformant_example_01.eps width=\textwidth
 *
 * But if you call a virtual keyboard, the window will resize, changing
 * widgets size and position. All the content will shrink.
 * The window will look like this:
 *
 * @image html screenshots/conformant_example_02.png
 * @image latex screenshots/conformant_example_02.eps width=\textwidth
 *
 * If you don't want such behaviour, you
 * will need a conformant to account for space taken up by the indicator,
 * virtual keyboard and softkey windows.
 *
 * In this case, using the conformant in a proper way, you will have
 * a window like the following when the virtual keyboard is hidden:
 *
 * @image html screenshots/conformant_example_03.png
 * @image latex screenshots/conformant_example_03.eps width=\textwidth
 *
 * As you can see, it guess the space that will be required by the keyboard.
 * Verify how perfectly it fits when keyboard is visible:
 *
 * @image html screenshots/conformant_example_04.png
 * @image latex screenshots/conformant_example_04.eps width=\textwidth
 *
 * So, let's study each step required to transform our initial example on
 * the second one.
 *
 * First of all, we need to set the window as an illume conformant window:
 * @dontinclude conformant_example_02.c
 * @skipline elm_win_conformant_set
 *
 * Next, we'll add a conformant widget, and set it to resize with the window,
 * instead of the box.
 * @skipline conform
 * @until evas_object_show
 *
 * Finally, we'll set the box as conformant's content, just like this:
 * @skipline elm_conformant_content_set
 *
 * Compare both examples code:
 * @ref conformant_example_01.c "conformant_example_01.c"
 * @ref conformant_example_02.c "conformant_example_02.c"
 *
 * @example conformant_example_01.c
 * @example conformant_example_02.c
 */

/**
 * @page index_example_01 Index widget example 1
 *
 * This code places an Elementary index widget on a window, which also
 * has a very long list of arbitrary strings on it.  The list is
 * sorted alphabetically and the index will be used to index the first
 * items of each set of strings beginning with an alphabet letter.
 *
 * Below the list are some buttons, which are there just to exercise
 * some index widget's API.
 *
 * Here's how we instantiate it:
 * @dontinclude index_example_01.c
 * @skip elm_list_add
 * @until evas_object_show(d.index)
 * where we're showing also the list being created. Note that we issue
 * elm_win_resize_object_add() on the index, so that it's set to have
 * the whole window as its container. Then, we have to populate both
 * list and index widgets:
 * @dontinclude index_example_01.c
 * @skip for (i = 0; i < (sizeof(dict) / sizeof(dict[0])); i++)
 * @until }
 * @until }
 *
 * The strings populating the list come from a file
 * @dontinclude index_example_01.c
 * @skip static const char *dict
 * @until }
 *
 * We use the @c curr char variable to hold the last initial letter
 * seen on that ordered list of strings, so that we're able to have an
 * index item pointing to each list item starting a new letter
 * "section". Note that our index item data pointers will be the list
 * item handles. We are also setting a callback function to index
 * items deletion events:
 * @dontinclude index_example_01.c
 * @skip static void
 * @until }
 *
 * There, we show you that the @c event_info pointer will contain the
 * item in question's data, i.e., a given list item's pointer. Because
 * item data is also returned in the @c data argument on
 * @c Evas_Smart_Cb functions, those two pointers must have the same
 * values. On this deletion callback, we're deleting the referred list
 * item too, just to exemplify that anything could be done there.
 *
 * Next, we hook to two smart events of the index object:
 * @dontinclude index_example_01.c
 * @skip smart_callback_add(d.index
 * @until _index_selected
 * @dontinclude index_example_01.c
 * @skip "delay,changed" hook
 * @until }
 * @until }
 *
 * Check that, whenever one holds the mouse pressed over a given index
 * letter for some time, the list beneath it will roll down to the
 * item pointed to by that index item. When one releases the mouse
 * button, the second callback takes place. There, we check that the
 * reported item data, on @c event_info, is the same reported by
 * elm_index_item_selected_get(), which gives the last selection's
 * data on the index widget.
 *
 * The first of the three buttons that follow will call
 * elm_index_active_set(), thus showing the index automatically for
 * you, if it's not already visible, what is checked with
 * elm_index_active_get(). The second button will exercise @b deletion
 * of index item objects, by the following code:
 * @dontinclude index_example_01.c
 * @skip delete an index item
 * @until }
 *
 * It will get the last index item selected's data and find the
 * respective #Elm_Index_Item handle with elm_index_item_find(). We
 * need the latter to query the indexing letter string from, with
 * elm_index_item_letter_get(). Next, comes the delition, itself,
 * which will also trigger the @c _index_item_del callback function,
 * as said above.
 *
 * The third button, finally, will exercise elm_index_item_clear(),
 * which will delete @b all of the index's items.
 *
 * This is how the example program's window looks like with the index
 * widget hidden:
 * @image html screenshots/index_example_00.png
 * @image latex screenshots/index_example_00.eps
 *
 * When it's shown, it's like the following figure:
 * @image html screenshots/index_example_01.png
 * @image latex screenshots/index_example_01.eps
 *
 * See the full @ref index_example_01_c "source code" for
 * this example.
 *
 * @example index_example_01.c
 */

/**
 * @page index_example_02 Index widget example 2
 *
 * This code places an Elementary index widget on a window, indexing
 * grid items. The items are placed so that their labels @b don't
 * follow any order, but the index itself is ordered (through
 * elm_index_item_sorted_insert()). This is a complement to to @ref
 * index_example_01 "the first example on indexes".
 *
 * Here's the list of item labels to be used on the grid (in that
 * order):
 * @dontinclude index_example_02.c
 * @skip static const char *items
 * @until };
 *
 * In the interesting part of the code, here, we first instantiate the
 * grid (more on grids on their examples) and, after creating our
 * index, for each grid item we also create an index one to reference
 * it:
 * @dontinclude index_example_02.c
 * @skip grid = elm_gengrid_add
 * @until }
 * @until smart_callback_add
 *
 * The order in which they'll appear in the index, though, is @b
 * alphabetical, becase of elm_index_item_sorted_insert() usage
 * together with the comparing function, where we take the letters of
 * each index item to base our ordering on. The parameters on
 * @c _index_cmp have to be declared as void pointers because of the
 * @c Eina_Compare_Cb prototype requisition, but in this case we know
 * they'll be #Elm_Index_Item's:
 * @dontinclude index_example_02.c
 * @skip ordering alphabetically
 * @until }
 *
 * The last interesting bit is the callback in the @c "delay,changed"
 * smart event, which will bring the given grid item to the grid's
 * visible area:
 * @dontinclude index_example_02.c
 * @skip static void
 * @until }
 *
 * Note how the grid will move kind of randomly while you move your
 * mouse pointer held over the index from top to bottom -- that's
 * because of the the random order the items have in the grid itself.
 *
 * This is how the example program's window looks like:
 * @image html screenshots/index_example_03.png
 * @image latex screenshots/index_example_03.eps
 *
 * See the full @ref index_example_c "source code" for
 * this example.
 *
 * @example index_example_02.c
 */

/**
 * @page bg_example_01_c bg_example_01.c
 * @include bg_example_01.c
 * @example bg_example_01.c
 */

/**
 * @page bg_example_02_c bg_example_02.c
 * @include bg_example_02.c
 * @example bg_example_02.c
 */

/**
 * @page bg_example_03_c bg_example_03.c
 * @include bg_example_03.c
 * @example bg_example_03.c
 */

/**
 * @page actionslider_example_01 Actionslider example
 * @include actionslider_example_01.c
 * @example actionslider_example_01.c
 */

/**
 * @page animator_example_01_c Animator example 01
 * @include animator_example_01.c
 * @example animator_example_01.c
 */

/**
 * @page transit_example_01_c Transit example 1
 * @include transit_example_01.c
 * @example transit_example_01.c
 */

/**
 * @page transit_example_02_c Transit example 2
 * @include transit_example_02.c
 * @example transit_example_02.c
 */

/**
 * @page general_functions_example_c General (top-level) functions example
 * @include general_funcs_example.c
 * @example general_funcs_example.c
 */

/**
 * @page clock_example_c Clock example
 * @include clock_example.c
 * @example clock_example.c
 */

/**
 * @page flipselector_example_c Flipselector example
 * @include flipselector_example.c
 * @example flipselector_example.c
 */

/**
 * @page fileselector_example_c Fileselector example
 * @include fileselector_example.c
 * @example fileselector_example.c
 */

/**
 * @page fileselector_button_example_c Fileselector button example
 * @include fileselector_button_example.c
 * @example fileselector_button_example.c
 */

/**
 * @page fileselector_entry_example_c Fileselector entry example
 * @include fileselector_entry_example.c
 * @example fileselector_entry_example.c
 */

/**
 * @page index_example_01_c Index example
 * @include index_example_01.c
 * @example index_example_01.c
 */

/**
 * @page index_example_02_c Index example
 * @include index_example_02.c
 * @example index_example_02.c
 */

 * @page layout_example_01_c layout_example_01.c
 * @include layout_example_01.c
 * @example layout_example_01.c
 */

/**
 * @page layout_example_02_c layout_example_02.c
 * @include layout_example_02.c
 * @example layout_example_02.c
 */

/**
 * @page layout_example_03_c layout_example_03.c
 * @include layout_example_03.c
 * @example layout_example_03.c
 */

/**
 * @page layout_example_edc An example of layout theme file
 *
 * This theme file contains two groups. Each of them is a different theme, and
 * can be used by an Elementary Layout widget. A theme can be used more than
 * once by many different Elementary Layout widgets too.
 *
 * @include layout_example.edc
 * @example layout_example.edc
 */
